
TypeScript基础篇：极客时间TypeScript开发实战（[梁宵](https://time.geekbang.org/course/detail/211-108620)）学习笔记。
===

## 01.“类型思维” 

* JavaScript 是一门动态弱类型语言，对变量的类型非常宽容。而TypeScript提供静态类型检查。
*  TypeScript是拥有类型系统的JavaScript的超集，可以编译为纯JavaScript。
* TypeScript有三个特点：

<p>1.类型检查：会在编译代码时进行严格的静态类型检查，可以再编码阶段发现可能存在的隐患，而不必把他们带到线上去<br>2.语言扩展：TypeScript会包括ES6，以及未来提案中的特性，比如异步操作和装饰器，也会从其他语言借鉴某些特性，比如接口和抽象类<br>3.工具特性：TypeScript可以编译成标准的JavaScript可以再任何浏览器和操作系统上运行</p>

* 使用TypeScript还能带来什么其他好处：比如Vscode自动补全，导航和重构功能，接口定义可以代替文档，同时也能提高开发效率。

## 02.强类型和弱类型
* JavaScript是一门动态弱类型语言。
* 强类型语言：不允许改变变量的数据类型，除非进行强制类型转换。
* 弱类型语言：变量可以被赋予不同的数据类型。
* 总结：在强类型语言中对变量类型有严格的要求，不同的变量是不能相互赋值的。
而弱类型语言则没有什么约束，虽然相对灵活，但是也更容易产生Bug。

##  03.静态类型语言和动态类型语言
* 静态类型语言通俗定义：在编译阶段确定所有变量的类型。
* 动态类型语言通俗定义：在执行阶段确定所有变量的类型。
* 总结：两者的好处坏处都是两面的不能一概而论，要具具体的情况而定<br>

|静态类型语言|动态类型语言|
|---|---|
|对类型极度严格|对类型非常宽松|
|立即发发现错误|Bug可能隐藏数月甚至数年|
|运行时性能好(时间和空间上)|运行时性能差(时间和空间上)|
|自文档化|可读性差|

## 04.编写TypeScript
* 使用npm命令初始化工程：

```bash
npm init -y
npm i typescript -g
tsc --init          //初始化
tsc ./src/index.ts  //编译
```

* 配置构建工具： webpack

<code>npm i webpack webpack-cli webpack-dev-server</code><br>
<code>npm i ts-loader typescript -D</code><br>
<p>并且在build文件夹中将<b>webpack.base.config.js</b>，<b>webpack.config.js</b>，<b>webpack.dev.config.js</b>，<b>webpack.pro.config.js</b>文件都配置好</p>

* 配置npm命令：

<code>"start": "webpack-dev-server --mode=development --config ./build/webpack.config.js",
</code><br>
<code>"build": "webpack --mode=production --config ./build/webpack.config.js",</code>

##  05.基本类型
* ES6中有六中基本类型：Boolean，Number，String，Symbol，undefined，null。除此之外还用引用类型：Arrary，Function，Object
* TS中ES6的基础之上还新增数据类型：void，any，never，元组类型，枚举类型，此外还有很多高级类型玩法
* 元组类型： 元组是特殊的数组，限制了元素的类型和个数。值得注意是元组的越界问题：数组有push方法如果在元组中push一个新的数据，编译器并不会报错，打印出来的结果也是三个，这是TS中其实是允许我们往元组中插入新的元素。但是却不允许我们进行越界访问，实际的开发中不建议这样使用
* 在undefined和null在TS中其实任何类型的子类型，他是允许赋值给任意类型的，但是编译器会报错，此时如果要修改就要在tsconfig.json中<code>"strictNullChecks":false</code>。如果你想使用比较严格的语法就要将其关闭
* never表示一个函数不可能有返回值，比如一个函数抛出一个异常，或者是死循环函数。

##  06.类型注解
* 作用：相当于强类型语法中的类型声明,可以对变量进行约束作用
* 语法：(变量、函数):type

##  07.枚举类型
* 在一个初始化角色判断的例子中，如果使用if-else的嵌套判断角色编码的话，代码的可读性很差，可维护性也很差，此时就可以使用枚举类型。
* 枚举： 就是一组有名字的常量集合。比如通讯录，拨打电话只需要记住人名
* 数字枚举：打印为对象，既可以使用值索引，也可以使用数字索引。实现原理是<b>反向映射</b>
* 字符串枚举：字符串枚举被编译成了只有成员名称作为了key，所以字符串枚举是不能作为反向映射的
* 异构枚举： 数字枚举和字符串枚举混用就构成了异构枚举。但是这种情况容易引起混淆不建议使用
* 性质：<br>
1.枚举成员定义后不允许修改的<br>
2.枚举成员包括常量枚举const，对已有成员的引用，常量表达式，需要被计算的枚举成员
* 常量枚举：用const声明的枚举,在编译阶段被移除，作用当我们不需要对象，而需要一个对象的值的时候就可以使用常量枚举，减少我们编译环境的代码
* 小结一下：程序中不容易记忆的硬编码，未来中可能改变的常量抽取出来，定义成枚举类型，提升程序的可读性和可维护性

##  08.接口
* 接口可以用来约束对象，函数，以及类的结构和类型，是一种代码协作的契约，我们必须遵守且不能改变

### 对象类型接口
* 对象类型接口一般用于后端传回数据后，对数据起一定约束作用。
* 假如后端传回数据中有约定之外的字段。TS会启用动态类型法，假如传入的对象满足接口的必要条件，则不会报错。但是如果直接传入对象字面量的话就会报错。绕过这个报错的方法一共有三种：

<p>1.把字面量复制给一个变量，然后再使用<br>2.使用类型断言：<br>&nbsp;&nbsp;2.1：在字面量后面添加as关键字<br>&nbsp;&nbsp;2.2：在字面量前面加上尖括号<br>&nbsp;&nbsp;类型断言的作用就是明确告诉编译器这个对象的类型，这样就会绕过类型检查。以上前两种方法是等价的，我们建议第一种种方法，因为第二种方法在React中会产生奇异<br>3.使用字符串索引签名，在接口中使用一个中括号里面使用字符串进行约束，这样这个对象就支持多个属性了<p>

* 接口成员属性：
<p>1.可选属性：在属性名后面添加问号，表示这个属性可以有也可以没有<br>2.只读属性：在属性前面添加readonly关键字<br>3.可索引属性：当你不确定有多少属性，就可以是使用。可以使用字符串索引，也可以使用数字来索引。</p>

### 函数类型接口
* 可以用一个接口来定义一个函数类型，还可以使用type关键字来使用类型别名
* 混合类型接口： 一个接口即可以定义函数，也可以像对象一样拥有属性和方法。但是注意的是这样我们就只能创建一个单例，如果想创建多个就需要封装在一个方法之中

##  09.函数
* 在js中对函数参数的个数是没有限制的，而在ts中对于函数的形参和实参必须一一对应。但是有的时候我们需要传入参数可选，这个时候就用到了可选参数<code>x ?:number</code>。值得注意的是可选参数必须在必选参数之后。
* 函数重载：如果两个函数重名，但是参数数量不同，就实现一个函数重载。好处：功能相似的实现函数使用不同的函数名称。TS要实现函数重载要求<b>先定义</b>一系列函数名相同的函数声明。在最类型最宽的地方实现函数。

##  10.类
* class关键字创建出来的类， <b>属性在实例上而不在原型上，而方法在原型上，与ES中不同的是，实例的属性必须具有初始值或者在构造函数中被初始化</b>

* 类的成员修饰符：public是默认的，说明对所有人都是可见的。
* private私有成员，只能在类的本身被调用，在类的实例和子类都是无法被调用的。值得注意的是我们可以在<code>构造函数使用私有成员属性</code>证明该类既无法被实例化也无法继承。
* protected受保护成员属性。只能在类和子类中被访问，而不能再类的实例中被访问。<code>构造函数使用受保护成员属性</code>证明该类不能被实例化，只能被继承（基类）。
* readonly 只读属性：那么该属性不能被更改，但是要进行初始化.
* 除了类的成员，构造函数的参数也可以添加修饰符。他的作用就是把参数直接变为实例属性。这样可以让我们的代码更为简洁。
* static类的静态成员 ：只能通过类名来调用，而不能用子类来调用

---

* abstract抽象类：只能被继承，可以定义方法里面有具体实现，这样子类就不用实现了。也可以在抽象类中定义方法但是不实现，构成一个抽象方法。好处：抽离一些事物的共性，有利于代码的复用。同样抽象类也可以实现多态。
* 多态：在父类我们可以定义一个抽象方法，在子类中有不同的实现，在程序运行的时候，可以根据对象的不同而进行不同的操作。

##  11.类和接口之间的关系
* 类类型接口在实现的过程中必须实现接口的所有属性。接口只能约束类的共有成员。
* 接口的继承，接口除了可以继承几口之外还可以继承类

<br>

<img width="100%" src="https://qbenben-1259133534.cos.ap-shenzhen-fsi.myqcloud.com/blog/%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png"/>

* 总结：首先接口之间是可以相互继承的实现接口的复用，类之间也可以相互继承实现方法和属性的复用，接口是可以通过类来实现的，但是接口只能约束类的共有成员，另外接口也可以抽离出类的成员，抽离的时候可以包括公有私有和受保护成员。

##  12.泛型
概念：不预先确定的数据类型，具体的类型在使用的时候才能确定。
* 泛型也可以约束类的成员参数，但是不能约束静态参数
* 泛型约束：使用一个接口在里面定义成员类型，然后用泛型继承
```JavaScript
interface Length{
  leng: number
}
function log<T extends Length>(value: T):T{
  console.log(value, value.length)
  return value
}
```

* 好处：
<p>1.函数和类可以轻松地支持多种类型，增强程序的可扩展性<br>2.不必写多条函数的重载，冗长的联合类型声明，增强程序的可读性<br>3.灵活控制类型之间的约束</p>

##  13.交叉类型和联合类型
* 交叉类型使用与 & 连接，其实交叉类型是取类型之间的并集并不是取交集。适合对象的混入
* 联合类型使用或 | 。就是该类型是这个类型或另一个类型，其实取得交集。适合类型之间的不确定性，增强代码灵活性
##   14.索引类型
* keyof 关键字返回类型的联合类型‘
* 索引类型可以实现对对象属性的查询访问，再配合泛型约束就可以建立对象，对象属性以及属性值之间的关系、

##  15、映射类型
* TS中有很多预设定的映射类型：Readonly，Partial，Pick，Record。通常结合索引类型，从而得到对象的属性和属性值，就可以得到我们想要的对象的结构。
##  16.条件类型
* T extends U ? X : Y
* 如果类型T可以U，结果就是X类型，否则就是Y类型
