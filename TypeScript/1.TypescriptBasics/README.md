
TypeScript基础篇：极客时间TypeScript开发实战（[梁宵](https://time.geekbang.org/course/detail/211-108620)）学习笔记。
===

## 01.“类型思维” 

* JavaScript 是一门动态弱类型语言，对变量的类型非常宽容。而TypeScript提供静态类型检查。
*  TypeScript是拥有类型系统的JavaScript的超集，可以编译为纯JavaScript。
* TypeScript有三个特点：

<p>1.类型检查：会在编译代码时进行严格的静态类型检查，可以再编码阶段发现可能存在的隐患，而不必把他们带到线上去<br>2.语言扩展：TypeScript会包括ES6，以及未来提案中的特性，比如异步操作和装饰器，也会从其他语言借鉴某些特性，比如接口和抽象类<br>3.工具特性：TypeScript可以编译成标准的JavaScript可以再任何浏览器和操作系统上运行</p>

* 使用TypeScript还能带来什么其他好处：比如Vscode自动补全，导航和重构功能，接口定义可以代替文档，同时也能提高开发效率。

## 02.强类型和弱类型
* JavaScript是一门动态弱类型语言。
* 强类型语言：不允许改变变量的数据类型，除非进行强制类型转换。
* 弱类型语言：变量可以被赋予不同的数据类型。
* 总结：在强类型语言中对变量类型有严格的要求，不同的变量是不能相互赋值的。
而弱类型语言则没有什么约束，虽然相对灵活，但是也更容易产生Bug。

##  03.静态类型语言和动态类型语言
* 静态类型语言通俗定义：在编译阶段确定所有变量的类型。
* 动态类型语言通俗定义：在执行阶段确定所有变量的类型。
* 总结：两者的好处坏处都是两面的不能一概而论，要具具体的情况而定<br>

|静态类型语言|动态类型语言|
|---|---|
|对类型极度严格|对类型非常宽松|
|立即发发现错误|Bug可能隐藏数月甚至数年|
|运行时性能好(时间和空间上)|运行时性能差(时间和空间上)|
|自文档化|可读性差|

## 04.编写TypeScript
* 使用npm命令初始化工程：

```bash
npm init -y
npm i typescript -g
tsc --init          //初始化
tsc ./src/index.ts  //编译
```

* 配置构建工具： webpack

<code>npm i webpack webpack-cli webpack-dev-server</code><br>
<code>npm i ts-loader typescript -D</code><br>
<p>并且在build文件夹中将<b>webpack.base.config.js</b>，<b>webpack.config.js</b>，<b>webpack.dev.config.js</b>，<b>webpack.pro.config.js</b>文件都配置好</p>

* 配置npm命令：

<code>"start": "webpack-dev-server --mode=development --config ./build/webpack.config.js",
</code><br>
<code>"build": "webpack --mode=production --config ./build/webpack.config.js",</code>

##  05.基本类型
* ES6中有六中基本类型：Boolean，Number，String，Symbol，undefined，null。除此之外还用引用类型：Arrary，Function，Object
* TS中ES6的基础之上还新增数据类型：void，any，never，元组类型，枚举类型，此外还有很多高级类型玩法
* 元组类型： 元组是特殊的数组，限制了元素的类型和个数。值得注意是元组的越界问题：数组有push方法如果在元组中push一个新的数据，编译器并不会报错，打印出来的结果也是三个，这是TS中其实是允许我们往元组中插入新的元素。但是却不允许我们进行越界访问，实际的开发中不建议这样使用
* 在undefined和null在TS中其实任何类型的子类型，他是允许赋值给任意类型的，但是编译器会报错，此时如果要修改就要在tsconfig.json中<code>"strictNullChecks":false</code>。如果你想使用比较严格的语法就要将其关闭
* never表示一个函数不可能有返回值，比如一个函数抛出一个异常，或者是死循环函数。

##  06.类型注解
* 作用：相当于强类型语法中的类型声明,可以对变量进行约束作用
* 语法：(变量、函数):type

##  07.枚举类型
* 在一个初始化角色判断的例子中，如果使用if-else的嵌套判断角色编码的话，代码的可读性很差，可维护性也很差，此时就可以使用枚举类型。
* 枚举： 就是一组有名字的常量集合。比如通讯录，拨打电话只需要记住人名
* 数字枚举：打印为对象，既可以使用值索引，也可以使用数字索引。实现原理是<b>反向映射</b>
* 字符串枚举：字符串枚举被编译成了只有成员名称作为了key，所以字符串枚举是不能作为反向映射的
* 异构枚举： 数字枚举和字符串枚举混用就构成了异构枚举。但是这种情况容易引起混淆不建议使用
* 性质：<br>
1.枚举成员定义后不允许修改的<br>
2.枚举成员包括常量枚举const，对已有成员的引用，常量表达式，需要被计算的枚举成员
* 常量枚举：用const声明的枚举,在编译阶段被移除，作用当我们不需要对象，而需要一个对象的值的时候就可以使用常量枚举，减少我们编译环境的代码
* 小结一下：程序中不容易记忆的硬编码，未来中可能改变的常量抽取出来，定义成枚举类型，提升程序的可读性和可维护性

##  08.接口
* 接口可以用来约束对象，函数，以及类的结构和类型，是一种代码协作的契约，我们必须遵守且不能改变

### 对象类型接口
* 对象类型接口一般用于后端传回数据后，对数据起一定约束作用。
* 假如后端传回数据中有约定之外的字段。TS会启用动态类型法，假如传入的对象满足接口的必要条件，则不会报错。但是如果直接传入对象字面量的话就会报错。绕过这个报错的方法一共有三种：

<p>1.把字面量复制给一个变量，然后再使用<br>2.使用类型断言：<br>&nbsp;&nbsp;2.1：在字面量后面添加as关键字<br>&nbsp;&nbsp;2.2：在字面量前面加上尖括号<br>&nbsp;&nbsp;类型断言的作用就是明确告诉编译器这个对象的类型，这样就会绕过类型检查。以上前两种方法是等价的，我们建议第一种种方法，因为第二种方法在React中会产生奇异<br>3.使用字符串索引签名，在接口中使用一个中括号里面使用字符串进行约束，这样这个对象就支持多个属性了<p>

* 接口成员属性：
<p>1.可选属性：在属性名后面添加问号，表示这个属性可以有也可以没有<br>2.只读属性：在属性前面添加readonly关键字<br>3.可索引属性：当你不确定有多少属性，就可以是使用。可以使用字符串索引，也可以使用数字来索引。</p>

### 函数类型接口
* 可以用一个接口来定义一个函数类型，还可以使用type关键字来使用类型别名
* 混合类型接口： 一个接口即可以定义函数，也可以像对象一样拥有属性和方法。但是注意的是这样我们就只能创建一个单例，如果想创建多个就需要封装在一个方法之中

##  09.函数
* 在js中对函数参数的个数是没有限制的，而在ts中对于函数的形参和实参必须一一对应。但是有的时候我们需要传入参数可选，这个时候就用到了可选参数<code>x ?:number</code>。值得注意的是可选参数必须在必选参数之后。
* 函数重载：如果两个函数重名，但是参数数量不同，就实现一个函数重载。好处：功能相似的实现函数使用不同的函数名称。TS要实现函数重载要求<b>先定义<b>一系列函数名相同的函数声明。在最类型最宽的地方实现函数。


